# Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
#
# 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
#
# It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.
#
# Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk − Pj| is minimised; what is the value of D?


pentagonal_numbers = Enumerator.new do |yielder|
  x = 1
  loop do
    yielder << x * (3 * x - 1) / 2
    x += 1
  end
end.with_index(1)

diffs = Enumerator.new do |yielder|
  x = 1
  loop do
    yielder << 3 * x - 2
    x += 1
  end
end.with_index(1)


pentagonal_diffs = Enumerator.new do |yielder|
  x = 1
  loop do
    diff = 3 * x - 2
    yielder << [diff, x] if is_pentagonal?(diff)
    x += 1
  end
end

def isqrt(n)
  x = n + 1  # Initialized value just needs to be bigger than xk
  xk = n

  while (x > xk)
    x = xk
    xk = (x + (n / x)) / 2
  end

  x
end

def pentagonal(n)
  n * (3 * n - 1) / 2
end

def pentagonal_diff_by_index(n, m)
  (n * (3 * n - 1) - m * (3 * m - 1)) / 2
end

def pentagonal_diff_by_offset(n, x)
  x * (6 * n - (3 * x + 1)) / 2
end

def is_square?(n)
  isqrt(n) ** 2 == n
end

def is_pentagonal?(n)
  pn = 24 * n + 1
  iroot = isqrt(pn)

  (iroot ** 2 == pn) && iroot % 6 == 5
end



require 'set'

ps = []
n = 1
loop do
  print "." if n % 1000 == 0
  p = pentagonal(n)
  ps << p
  (2...n).each do |d|
    pp = p - ps[-d]
    puts "\n#{pp}, #{p}" if is_pentagonal?(p - pp) && is_pentagonal?(p + pp)
    break
  end
  n += 1
  break if n > 100_000_000
end







# f(n+1) - f(n) = (n+1) * (3 * (n+1) - 1) / 2    -    n * (3 * n - 1) / 2
# f(n+1) - f(n) = (n+1) * (3n + 2) / 2    -    n * (3 * n - 1) / 2
# f(n+1) - f(n) = (3n^2 + 5n + 2) / 2    -    (3n^2 - n) / 2
# f(n+1) - f(n) = (4n + 2) / 2

# f(n) - f(n-1) = (n) * (3 * n - 1) / 2    -    (n-1) * (3 * (n-1) - 1) / 2
# f(n) - f(n-1) = (3n^2 - n) / 2    -    (n-1) * (3n-4) / 2
# f(n) - f(n-1) = (3n^2 - n) / 2    -    (3n^2 - 7n + 4) / 2
# f(n) - f(n-1) = (6n - 4) / 2
# f(n) - f(n-1) = 3n - 2

# f(n) - f(n-x) = (n) * (3 * n - 1) / 2    -    (n-x) * (3 * (n-x) - 1) / 2
# f(n) - f(n-x) = (3n^2 - n) / 2    -    (n-x) * (3n - 3x - 1) / 2
# f(n) - f(n-x) = (3n^2 - n) / 2    -    (3n^2 - 6nx - n + 3x^2 + x) / 2
# f(n) - f(n-x) = (-n) / 2    -    (-6nx - n + 3x^2 + x) / 2
# f(n) - f(n-x) = (-n) / 2    +    (6nx + n - 3x^2 - x) / 2
# f(n) - f(n-x) = (6nx - 3x^2 - x) / 2
# f(n) - f(n-x) = (6nx - x(3x + 1)) / 2
# f(n) - f(n-x) = x(6n - (3x + 1)) / 2

# f(n,m) = f(n) - f(m) = (3n^2 - n) / 2 - (3m^2 - m) / 2
# f(n,m) = f(n) - f(m) = (n(3n - 1) - m(3m - 1)) / 2



### -------------------------------------------------------------------

# checked_numbers = []
# checked_numbers << pentagonal_numbers.next
# solutions = []

# diff_pairs = []
# j = 0

# # solution = catch(:solution) do
#   loop do
#     x, idx_x = pentagonal_numbers.next
#     j += 1

#     min_difference = x - checked_numbers.last[0]
#   # puts "Min: #{min_difference}"

#     # i = checked_numbers.length - 1
#   # puts "#{x} #{min_difference}"
#   # puts checked_numbers.inspect


#     # while checked_numbers[i] >= min_difference
#     checked_numbers.each do |checked_number, idx|
#       next if checked_number < min_difference


#   # puts "#{x} #{min_difference} #{checked_numbers[i]} (#{(x - checked_numbers[i])})"

#       if diff = checked_numbers.bsearch{|n, k| (x - checked_number) <=> n }

#         # puts "x: #{x}, diff: #{diff}, checked_number: #{checked_number}"
# #         puts "------------\nx: #{x}, diff: #{diff}, checked_number: #{checked_number} - [#{checked_number}, #{diff}]"

#         # lower_diff = diff_pairs.bsearch{|n, m| puts "((#{checked_number} <=> #{n}) * 2) + (#{diff} <=> #{m}) = (#{(checked_number <=> n)} * 2) + #{(diff <=> m)} = #{((checked_number <=> n) * 2) + (diff <=> m)}"; ((checked_number <=> n) * 2) + (diff <=> m) }
#         lower_diff = diff_pairs.bsearch{|n, m| ((checked_number <=> n) * 2) + (diff[0] <=> m) }
#         if lower_diff
#           # throw(:solution, [[x, checked_number, j], lower_diff])
#           solutions << [[x, checked_number, j], lower_diff]
#         end

#         diff_pairs << [x, checked_number, idx_x + 1]
# # puts checked_numbers.inspect
# # puts diff_pairs.inspect
#       end
#       # i -= 1
#     end

#     checked_numbers << [x, idx_x]

#     break if x >= 200_000_000
#   end
# # end

# # puts "#{solution.inspect} : #{solution[0].last - solution[1].last}"
# solutions.each {|y| puts y.inspect}

# =begin

#   n(3n-1)/2 = (n+x)(3(n+x)-1)/2
